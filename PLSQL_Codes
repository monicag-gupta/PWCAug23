

BEGIN
DECLARE @product_table TABLE (
    product_name VARCHAR(MAX) NOT NULL,
    brand_id INT NOT NULL,
    list_price DEC(11,2) NOT NULL
);
INSERT INTO @product_table
     SELECT product_name, brand_id, list_price
         FROM BikeStores.production.products WHERE category_id = 1;

SELECT  p.product_name, p.brand_id, p.list_price FROM @product_table p join BikeStores.production.products
on p.list_price=BikeStores.production.products.list_price;
END




Restrictions on table variables:
First, you have to define the structure of the table variable during the declaration. Unlike a regular or temporary table, you cannot alter the structure of the table variables after they are declared.
Second, statistics help the query optimizer to come up with a good query’s execution plan. Unfortunately, table variables do not contain statistics. Therefore, you should use table variables to hold a small number of rows.
Third, you cannot use the table variable as an input or output parameter like other data types. However, you can return a table variable from a user-defined function
Fourth, you cannot create non-clustered indexes for table variables. However, starting with SQL Server 2014, memory-optimized table variables are available with the introduction of the new In-Memory OLTP that allows you to add non-clustered indexes as part of table variable’s declaration.
Fifth, if you are using a table variable with a join, you need to alias the table in order to execute the query.











BEGIN
DECLARE @product_table TABLE (
    product_name VARCHAR(MAX) NOT NULL,
    brand_id INT NOT NULL,
    list_price DEC(11,2) NOT NULL
);
INSERT INTO @product_table
     SELECT product_name, brand_id, list_price
         FROM BikeStores.production.products WHERE category_id = 1;

SELECT  * FROM @product_table;
END










The following are some key takeaway of the scalar functions:
	Scalar functions can be used almost anywhere in T-SQL statements.
	Scalar functions accept one or more parameters but return only one value, therefore, they must include a RETURN statement.
	Scalar functions can use logic such as IF blocks or WHILE loops.
	Scalar functions cannot update data. They can access data but this is not a good practice.
	Scalar functions can call other functions.








DROP FUNCTION dbo.fn2;






create or Alter FUNCTION fn2(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 1;
	WHILE @x > 0
	BEGIN
	       set @sm = @x * @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn2(5);











Alter FUNCTION fn(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 1;
	WHILE @x > 0
	BEGIN
	       set @sm = @x * @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn(5);










CREATE FUNCTION fn(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 0;
	WHILE @x > 0
	BEGIN
	       set @sm = @x + @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn(5);







CREATE FUNCTION udfNetSale(
    @quantity INT,
    @list_price DEC(10,2),
    @discount DEC(4,2)
)
RETURNS DEC(10,2)
AS 
BEGIN
    RETURN @quantity * @list_price * (1 - @discount);
END;



SELECT dbo.udfNetSale(10,100,0.1) as net_sale;  --900

SELECT testdb.dbo.udfNetSale(10,list_price,0.1) as net_sale from bikestores.production.products;








Check if the products table have total even number of records or odd number of records.
Print wise messages accordingly.







BEGIN
    DECLARE @name VARCHAR(MAX);

    SELECT TOP 1  @name = product_name
    FROM   bikeStores.production.products
    ORDER BY list_price DESC;
	
    IF @@ROWCOUNT <> 0
    BEGIN
        PRINT 'The most expensive product is ' + @name
    END
    ELSE
    BEGIN
        PRINT 'No product found';
    END;
END
--The most expensive product is Trek Domane SLR 9 Disc - 2018





BEGIN
    SELECT product_id, product_name
    FROM bikestores.production.products  WHERE list_price > 1000000;

    IF @@ROWCOUNT = 0
            PRINT 'No product with price greater than 100000 found';
    Else
	  Print 'Product with the given price range found';
END

--Output : No product..










Begin
	DECLARE @counter INT = 0;
	WHILE @counter <= 5
	BEGIN
		SET @counter = @counter + 1;
		IF @counter = 4
			BREAK;
		PRINT @counter;
	END
End
--1 2 3 

Begin
	DECLARE @counter INT = 0;

	WHILE @counter < 5
	BEGIN
		SET @counter = @counter + 1;
		IF @counter = 3
			CONTINUE;
		PRINT @counter;
	END
End

--1 2 4 5 





Begin
	DECLARE @counter INT = 1;
	WHILE @counter <= 5
	BEGIN
		PRINT @counter;
		SET @counter = @counter + 1;
	END
End
--1 2 3 4 5 





if (5>6)
	Begin
		print '5 is greater'
		print 'End of if'
	end
Else
	Begin
		print '5 is smaller'
		print 'End of else'
	end









if (5>3)
  print '5 is greater'

if (5>3)
Begin
   print '5 is greater'
   print 'End of if'
end






SELECT COUNT(*) FROM customers;
SELECT MIN(Salary) FROM customers;
SELECT MAX(Salary) FROM customers;
SELECT AVG(Salary) FROM customers;
SELECT SUM(Salary) FROM customers;
Select SQRT(16);  
SELECT RAND()*(10-5)+5;  --Random between 5 and 10; includes decimal
SELECT CAST(RAND()*(10-5)+5 as int); --only int output
Select Rand(1); --will generate the same number as it will be generated only once for the seed value given. 
SELECT CONCAT('FIRST ', 'SECOND');
SELECT FLOOR(7.55);  --7.0
select ceiling(5.3); --6
--SELECT FORMAT(423423234.65434453,2);  -- 423,423,234.65
SELECT 29 % 3;  --2
SELECT POWER(2,3);  --8
SELECT PI(); -- 3.141593
--SELECT TRUNCATE(7.536432,2);  --  7.53
SELECT CURRENT_USER;  --Monica
SELECT ISNUMERIC('4567');  --1
SELECT CONVERT(int, 25.65); --25
select soundex('bat'),soundex('What'); --4 char set telling the sound 
--bat : B300, What : w300
select difference('Bat','Ball'); 
--the more similar to sound, the better numerical value between (0-4): 
--The number of char same in soundex
select difference('Wall','Ball');
select difference('Bat','what');
SELECT ASCII('A');  -- 65
SELECT CHAR(65); -- A
SELECT LOWER('STR'); --str
SELECT UPPER('Str');  --STR
SELECT LEN('text');  -- 4
SELECT LEFT('SQL Session', 3); --SQL  
SELECT RIGHT('SQL Session', 3); --ion
SELECT REVERSE('SQL Tutorial');  --lairotuT LQS
SELECT TRIM('     SQL Tutorial!     ')  --SQL Tutorial!
SELECT RTRIM('     SQL Tutorial!     ')  -- '     SQL Tutorial!'
SELECT LTRIM('     SQL Tutorial!     ')  -- 'SQL Tutorial!     '
SELECT STR(185);  --’185’
SELECT STUFF('SQL Tutorial', 1, 3, 'C#');  --C# Tutorial
SELECT SUBSTRING('SQL Tutorial', 1, 3) --SQL
SELECT TRANSLATE('3*[2+1]/{8-4}', '[]{}', '()()');  -- 3*(2+1)/(8-4)
SELECT TRANSLATE('Hello World', 'ol', 'ab');  -- Hebba Warbd
SELECT CURRENT_TIMESTAMP; --2023-09-01 10:40:50.923
SELECT GETDATE(); --2020-11-01 10:41:40.830
SELECT Concat(DAY(GETDATE()), '-', MONTH(GETDATE()), '-', YEAR(GETDATE())); --1-11-2020
SELECT IIF(500<1000, 'YES', 'NO'); --YES
SELECT NULLIF(25, 25);  --Returns NULL since equal
SELECT NULLIF(25, 66);  --Returns 25  since not equal
select COALESCE((null),(null),(2),(6),(null),(100)); --2
select isnull(null,'Null value'); -- Null value
select isnull(6,'Null value'); --6




















SELECT * FROM CUSTOMERS WHERE SALARY > 5000;
SELECT * FROM CUSTOMERS WHERE SALARY = 2000;
SELECT * FROM CUSTOMERS WHERE SALARY != 2000;
SELECT * FROM CUSTOMERS WHERE SALARY <> 2000;
SELECT * FROM CUSTOMERS WHERE SALARY >= 6500;
SELECT * FROM CUSTOMERS WHERE AGE >= 25 AND SALARY >= 6500;
SELECT * FROM CUSTOMERS WHERE AGE >= 25 OR SALARY >= 6500;
SELECT * FROM CUSTOMERS WHERE AGE IS NOT NULL;
SELECT * FROM CUSTOMERS WHERE NAME LIKE 'Ko%';
SELECT * FROM CUSTOMERS WHERE AGE IN ( 25, 27 );
SELECT * FROM CUSTOMERS WHERE AGE BETWEEN 25 AND 27;
SELECT AGE FROM CUSTOMERS WHERE EXISTS (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
SELECT * FROM CUSTOMERS WHERE AGE > ALL (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
SELECT * FROM CUSTOMERS WHERE AGE > ANY (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);


select name, age from customers where age > any(select age from CUSTOMERS_Bkp2);
select name, age from customers where age > all(select age from CUSTOMERS_Bkp2);
select name, age from customers where exists (select age from CUSTOMERS_Bkp2 where age > 2);
select name, age from customers where exists (select age from CUSTOMERS_Bkp2 where age > 27);
select name, age from customers where not exists (select age from CUSTOMERS_Bkp2 where age > 27);














select @@CONNECTIONS as 'Number of Login Attempts';
SELECT * From  Employee_Details
if(@@ERROR <> 0)
   print 'Error Found'
else
   print 'Error not Found'
Select @@IDENTITY as identityvalue;
select @@IDLE as 'idle milliseconds Time'
select @@CPU_BUSY  as 'Busy milliseconds Time'
SELECT @@LANGUAGE as 'Language'
SELECT * FROM Employee_Details
SELECT @@rowcount as 'Count Number of Rows affected'
Select @@SERVICENAME as 'ServiceName'
SELECT  @@Total_ERRORS  as 'number of disk read-write errors'
SELECT  @@VERSION  as 'SQL Server Version'
SELECT  @@SERVERNAME  as 'Server Name'













@@CONNECTIONS 
This variable returns the number of login attempts since SQL Server was last started. It returns an integer value.
@@IDLE
This variable returns the number of milliseconds SQL Server has been idle since it was last started.
@@CPU_BUSY
This system function returns the number of milliseconds the CPU has spent working since SQL Server was last started. It returns an integer value.
@@LANGUAGE
This system function returns the name of the language that is currently used by the SQL Server.
@@SERVERNAME 
This variable returns the name of the service under which SQL Server is running.
@@VERSION  
This variable returns the current version of the SQL Server Software.
@@SERVERNAME
This function retrieves the name of the database server the application is linked to.






@@CONNECTIONS 
This variable returns the number of login attempts since SQL Server was last started. It returns an integer value.
@@ERROR 
The error number for the last T-SQL statement executed. If this value is zero than there were no errors otherwise it returns the error.  
@@IDENTITY
@@IDENTITY will return the last identity value entered into a table. 
@@IDLE
This variable returns the number of milliseconds SQL Server has been idle since it was last started.
@@CPU_BUSY
This system function returns the number of milliseconds the CPU has spent working since SQL Server was last started. It returns an integer value.
@@LANGUAGE
This system function returns the name of the language that is currently used by the SQL Server.
@@ROWCOUNT
This variable returns the number of rows affected by the last Transact-SQL statement.  
@@SERVERNAME 
This variable returns the name of the service under which SQL Server is running.
@@TOTAL_ERRORS
The @@TOTAL_ERRORS function returns the number of disk read/write errors encountered by SQL Server since it was last started. It returns an integer value.
@@VERSION  
This variable returns the current version of the SQL Server Software.
@@SERVERNAME
This function retrieves the name of the database server the application is linked to.








In testdb database, customers table: print what will be the salary of Kaushik if he gets a 15% hike in his current salary.
Use batch programming and a numerical variable for calculations:
Output:
With salary hike, Kaushik now gets : (new salary)

Declare a var. 
Set it to current salary of kaushik
Set it to 15 % hike
Print it with proper message








Begin
DECLARE 
    @product_name VARCHAR(MAX),
    @list_price DECIMAL(10,2);

SELECT 
    @product_name = product_name,
    @list_price = list_price
FROM
    bikestores.production.products
WHERE
    product_id = 1;

SELECT 
    @product_name AS product_name, 
    @list_price AS list_price;
End









Begin
 	SET NOCOUNT ON; 
	DECLARE @product_count INT;
	SET @product_count = (
           SELECT COUNT(*) FROM productsNew);
	--Print @product_count;
 	--PRINT 'The number of products is ' + CAST(@product_count AS VARCHAR(MAX));
 	SELECT @product_count;
End








Begin
	DECLARE @model_year SMALLINT;
	SET @model_year = 2018;
	SELECT
		product_name, model_year, list_price 
	FROM productsNew
	WHERE 
		model_year = @model_year
	ORDER BY product_name;
End





CREATE TABLE productsNew (
	product_id INT IDENTITY (1, 1) PRIMARY KEY,
	product_name VARCHAR (255) NOT NULL,
	brand_id INT NOT NULL,
	category_id INT NOT NULL,
	model_year SMALLINT NOT NULL,
	list_price DECIMAL (10, 2) NOT NULL);



INSERT INTO productsNew
VALUES 
 	('Test product1', 1, 1, 2018, 599),
 	('Test product2', 2, 2, 2016, 699),
 	('Test product3', 3, 3, 2018, 799),
 	('Test product4', 4, 4, 2015, 899);
