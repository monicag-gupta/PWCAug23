using System;

namespace Prj1Day17
{
    //chain of Responsibility
    class A
    {
        string security;
        public A() { security = "Normal security from A"; }
        public A(string s)
        {
            security = s;
        }
        public B fnA(string uname) //command pattern to get Obj of B following certain rule
        {
            return new B(security, uname);
        }
    }
    class B
    {
        string uname;

        public B() { uname = "Visitor"; }
        public B(string s, string na)
        {
            uname = na + s;
        }
        public C fnB()
        {
            return new C(uname);
        }

    }
    class C
    {
        string msg;
        public C() { msg = "";  }
        public C(string s)
        {
            msg = s;
        }
        public void fnC(string m)
        {
            Console.WriteLine("In C : " + msg + " " + m);
        }
    }


    internal class Program
    {
        static void Main(string[] args)
        {
            C c = new A("High End Security").fnA("Guest").fnB();
            c.fnC("Welcome Message to be printed");
        }
    }
}












using System;

namespace Prj1Day17
{
    class MessageRule1
    {
        string s;   
        public void setMsg(string s)
        {
            this.s = s;
        }
        public void getMsg()
        {
            Console.WriteLine(s);

        }

    }
    class MessageRule2
    {
        string protocols = " + security protocols";
        public MessageRule2() { }
        public MessageRule2(string p)
        {
            protocols = p;
        }
        public MessageRule1 getMsgSecurity(string s)
        {
            MessageRule1 m1 = new MessageRule1();
            m1.setMsg(s + protocols);
            return m1;
        }
    }
    class MessageRule3
    {
        string uname = " Username : ";
        public MessageRule3() { }
        public MessageRule3(string n)
        {
            uname = n;
        }
        public MessageRule2 getMsgUsername(string s, string s2)
        {
            MessageRule2 m2 = new MessageRule2(uname + s2);
            //m2.getMsgSecurity(uname + s);
            return m2;
        }
        public MessageRule2 getMsgUsername(string s)
        {
            MessageRule2 m2 = new MessageRule2();
            //m2.getMsgSecurity(uname + s);
            return m2;
        }
    }


    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Enter your message");
            string msg = Console.ReadLine();
            MessageRule3 m3 = new MessageRule3("Guest");
            MessageRule2 m2 = m3.getMsgUsername(msg, "High Security Protocols");
            MessageRule1 m1 = m2.getMsgSecurity(msg);
            m1.getMsg();
        }
    }
}













Factory Method
The Factory Method pattern allows you to create objects in a superclass and allows subclasses to change the type of objects that will be created. It’s a specialization of the Template Method, which defines the framework of an algorithm in a superclass and allows the subclasses to override steps of the algorithm without changing the framework.
Use cases : Here are some use cases of the Factory Method design pattern:
You don’t know the types and dependencies of objects your code works with
You want to save your system’s resources and reuse existing objects instead of creating new ones
You want to provide your library to users with the option to add to its components
You need a lot of flexibility in your code
Pros:
You can move the product creation code into one place
You can avoid tight coupling between the creator and the products
Cons:
Your code may become overly complicated because of all the subclasses within the pattern

Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

The classes and objects participating in this pattern are: 
Product  (Page) 
defines the interface of objects the factory method creates
ConcreteProduct  (SkillsPage, EducationPage, ExperiencePage) 
implements the Product interface
Creator  (Document) 
declares the factory method, which returns an object of type Product. Creator may also define a default implementation of the factory method that returns a default ConcreteProduct object. 
may call the factory method to create a Product object. 
ConcreteCreator  (Report, Resume) 
overrides the factory method to return an instance of a ConcreteProduct.









Abstract Factory

The Abstract Factory pattern allows you to create families of related objects without indicating their concrete classes.
Use cases : Here are some use cases of the Abstract Factory design pattern:
You need your code to work with families of related objects, but you don’t want your code to rely on concrete classes
You want to extend or customize your standard components
Pros:
You can bring new variations of products into the application without changing the existing code
You can pull the product creation code to one place
You can avoid tight coupling between client code and products
Cons:
You could end up with overly complicated code because of the interfaces and classes that come with the pattern


Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 

The classes,objects and interfaces used in the above UML diagram is described below: 
Client: This class is used Abstract Factory and Abstract Product interfaces to create family of related objects. 
Abstract Factory: This is an interface which is used to create abstract products. 
Abstract Product: This is an interface which is used to declare type of products. 
Concrete Factory: This is a class which implements the abstract factory interface to create concrete products. 
Concrete Product: This is a class which implements the abstract product interface to create products. 







Builder

The Builder pattern allows you to build complex objects one step at a time and produce different representations of an object using the same construction code.
Use cases: Here are some use cases of the Builder design pattern:
You want to be able to create different representations of objects
You want to build complex objects
You don’t want to cram multiple parameters into your constructors
Pros:
You can reuse your construction code when building different versions of products
You can build objects one step at a time
Cons:
Your code may become complex from the new classes that come with the pattern






Singleton Pattern 

Singleton design pattern is one of simplest design patterns. 
This pattern ensures that class has only one instance and provides global point of accessing it. 
The pattern ensures that only one object of a particular class is ever created.
All further references to objects of the singleton class refer to the same underlying instance. 
There are situations in a project where we want only one instance of the object to be created and shared between the clients. 
No client can create an instance from outside. 

1. Class should have private constructor: This will disallow us to create any instance outside the class.
2. Private static single instance of the class : the static memory allocation will help the instance to be created only once.
3. Public static getInstance() : this method is static as it will be called by class and wont require instance call. The method is public, as it will be used to create a reference to singleton class
Inside the method: create new memory if single instance has null value(is getting created for the first time). Return the single instance

The classes and objects participating in this pattern are: 
Singleton   (LoadBalancer) 
defines an Instance operation that lets clients access its unique instance. Instance is a class operation. 
responsible for creating and maintaining its own unique instance.


























Singleton Pattern:

using System;

namespace Prj1Day17
{
    class Singleton
    {
        private static Singleton singleObj;
        public string msg;
        private Singleton()
        { 
        }
        public static Singleton GetSingletonObj()
        {
            if (singleObj == null)
            {
                singleObj = new Singleton();
            }
            return singleObj;
        }


    }
    
    internal class Program
    {
        static void Main(string[] args)
        {
            Singleton obj1 = Singleton.GetSingletonObj();
            obj1.msg = "From Obj1 of Singleton class";
            Singleton obj2 = Singleton.GetSingletonObj();
            obj2.msg = "From Obj2 of Singleton class";
            Console.WriteLine("Obj1's msg : " + obj1.msg);
            Console.WriteLine("Obj2's msg : " + obj2.msg);
            Console.WriteLine("The above are the same proving that its the same object");

        }
    }
}








Prototype Pattern:

using System;

namespace Prj1Day17
{
    interface Messenger
    {
        void setMsg(string s);
        string send();
        void receive(string s);
    }
    class WhatAp : Messenger //Model
    {
        private string msg;
        public void setMsg(string s)
        {
            msg = s;
        }
        public string send()
        {
            return msg;
        }
        public void receive(string s)
        {
            Console.WriteLine("Read: " + s);
        }
    }
    class PrototypeWhatsApWeb //From the Model : the Original
    {
        private string name;
        public PrototypeWhatsApWeb()
        {

        }
        public PrototypeWhatsApWeb(string n)
        {
            name = n;
        }
        private string msg;
        Messenger app = new WhatAp();
        public void setMsg(string s)
        {
            app.setMsg(s);
        }
        public string send()
        {
            return app.send();
        }
        public void receive(string s)
        {
            s = " By " + name + " : " + s;
            app.receive(s);
        }

    }
    internal class Program
    {
        static void Main(string[] args)
        {
            PrototypeWhatsApWeb msngr1 = new PrototypeWhatsApWeb("Messenger1");
            PrototypeWhatsApWeb msngr2 = new PrototypeWhatsApWeb("Messenger2");
            Console.WriteLine("Enter your msg as Msngr1:");
            string msg = Console.ReadLine();
            msg = "Message from Messenger1 : " + msg;
            msngr1.setMsg(msg);
            msngr2.receive(msngr1.send());


        }
    }
}









Builder Pattern:


using System;

namespace Prj1Day17
{
    interface IHouse
    {
        void buildFloor();
        void buildCeiling();

    }
    class IglooHouse : IHouse
    {
        public void buildCeiling()
        {
            Console.WriteLine("Ceiling with IceDome");
        }

        public void buildFloor()
        {
            Console.WriteLine("Floor with IceBlocks");
        }
    }
    class TipiHouse : IHouse
    {
        public void buildCeiling()
        {
            Console.WriteLine("Ceiling with Wooden Carvings");
        }

        public void buildFloor()
        {
            Console.WriteLine("Floor with Wooden blocks");
        }
    }
    class BambooHouse : IHouse
    {
        public void buildCeiling()
        {
            Console.WriteLine("Ceiling with Bamboo strips");
        }

        public void buildFloor()
        {
            Console.WriteLine("Floor with bamboo blocks");
        }
    }
  
    class BuilderHouse
    {
        public IHouse GetHouse()
        {
            Console.WriteLine("Which house do you prefer: \n1. Bamboo");
            Console.WriteLine("2. Igloo\n3. Wooden\n Enter choice:");
            int ch=Convert.ToInt32(Console.ReadLine());
            if (ch == 1)
                return new BambooHouse();
            else if (ch == 2)
                return new IglooHouse();
            else
                return new TipiHouse();
        }
        public void buildHouse()
        {
            IHouse house = GetHouse();
            house.buildCeiling();
            house.buildFloor();
        }

    }
    internal class Program
    {
        static void Main(string[] args)
        {
            BuilderHouse builder = new BuilderHouse();
            builder.buildHouse();

        }
    }
}





using System;

namespace Prj1Day17
{
    interface myIterator
    {
        int next();
        bool hasNext();
        void begin();

    }
    class intIterator : myIterator
    {
        myIntCollection myintCollection;
        public intIterator(myIntCollection myintCollection)
        {
            this.myintCollection = myintCollection;
        }
        public void begin()
        {
            myintCollection.SOI = 0;
        }

        public int next()
        {
            return myintCollection.arr[myintCollection.SOI++];

        }

        public bool hasNext() {
            return  myintCollection.SOI< myintCollection.tos;
        }
    }
    class myIntCollection {
        public int[] arr = new int[1000];
        public int tos = -1;
        public int SOI=0;
        public void add(int i)
        {
            if(tos >= 1000)
            {
                Console.WriteLine("Stack Overflow");
            }
            else
            {
                arr[++tos] = i;
            }
        }
        public void remove(int i)
        {
            for (int j = 0; j <= tos; j++)
            {
                if (arr[j] == i)
                {
                    for (int k = j; k < tos; k++)
                    {
                        arr[k] = arr[k + 1];

                    }
                    tos--;
                }
            }
        }
        

    }
    internal class Program
    {
        static void Main(string[] args)
        {
            myIntCollection myInts = new myIntCollection();
            for(int i = 10; i < 20; i++){
                myInts.add(i * i);
            }
            myIterator it = new intIterator(myInts);
            for (it.begin(); it.hasNext();)
            {
                Console.WriteLine(it.next());
            }


        }
    }
}











Abstract Factory:

using System;

namespace Prj1Day17
{
    interface IShape
    {
        string getShape();
    }
    class Triangle: IShape
    {
        public string getShape()
        {
            return "Triangle";
        }
    }
    class Square : IShape
    {
        public string getShape()
        {
            return "Square";
        }
    }
    class Circle : IShape
    {
        public string getShape()
        {
            return "Circle";
        }
    }
    class ShapeFactory
    {
        public IShape getShaperObj(string S)
        {
            if (S.ToLower() == "triangle")
            {
                return new Triangle();
            }
            else if (S.ToLower() == "circle")
            {
                return new Circle();
            }
            else
                return new Square();
        }
    }
    interface IColor
    {
        string getColor();
    }
    class Red : IColor
    {
        public string getColor()
        {
            return "Red";
        }
    }
    class Green : IColor
    {
        public string getColor()
        {
            return "Green";
        }
    }
    class Blue : IColor
    {
        public string getColor()
        {
            return "Blue";
        }
    }
    class ColorFactory
    {
        public IColor getColorObj(string C)
        {
            if (C.ToLower() == "red")
            {
                return new Red();
            }
            else if (C.ToLower() == "green")
            {
                return new Green();
            }
            else
                return new Blue();
        }
    }
    class AbstractFactoryShapeColor
    {
        IColor color;
        IShape shape;
        public AbstractFactoryShapeColor(string C, string S)
        {
            this.color = new ColorFactory().getColorObj(C);
            this.shape = new ShapeFactory().getShaperObj(S);
        }
        public void draw()
        {
            Console.WriteLine("Draw the " + shape.getShape() + " in Color: " + color.getColor());
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Choose the Color : Red / Green / Blue");
            string c = Console.ReadLine();
            Console.WriteLine("Choose the Shape : Triangle / Circle / Square");
            string s = Console.ReadLine();
            AbstractFactoryShapeColor absFactory = new AbstractFactoryShapeColor(c, s);
            absFactory.draw();
            //ColorFactory factory = new ColorFactory();
            //IColor color = factory.getColorObj(c);
            //string clor = color.getColor();
            //Console.WriteLine(clor + " is choosen");
        }
    }
}
















Factory Pattern:


using System;

namespace Prj1Day17
{
    interface IColor
    {
        string getColor();
    }
    class Red : IColor
    {
        public string getColor()
        {
            return "Red";
        }
    }
    class Green : IColor
    {
        public string getColor()
        {
            return "Green";
        }
    }
    class Blue : IColor
    {
        public string getColor()
        {
            return "Blue";
        }
    }
    class ColorFactory
    {
        public IColor getColorObj(string C)
        {
            if (C.ToLower() == "red")
            {
                return new Red();
            }
            else if (C.ToLower() == "green")
            {
                return new Green();
            }
            else
                return new Blue();
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Choose the Color : Red / Green / Blue");
            string c = Console.ReadLine();
            ColorFactory factory = new ColorFactory();
            IColor color = factory.getColorObj(c);
            string clor = color.getColor();
            Console.WriteLine(clor + " is choosen");
        }
    }
}
